
<< Snake Game Hamilton PseudoCode >>


for neighbor in neighbors(node):
    if head bigger tail:
        exclude node between head and food
    if head smaller than tail:
        exclude node less than head or bigger than tail


if headIndex is less than foodIndex:
    find largest neighbor that is less than foodIndex
    for n in neighbors:
        if n > largest:
            largest = n


else if headIndex is greater than foodIndex:
    // Wrap around
    if any neighborIndex is less than food:
        neighborIndex = neighborIndex + length of hamiltonian cycle
        foodIndex = foodIndex + length of hamiltonian cycle
        best = highest neighborIndex while lower then foodIndex
        
    else if no neighborIndexes are less than the food:
        best = highest neighbor


! FAILED ALGORITHMS !

"""
    def esafe(tuple):
        foodIndex = path.index(food.pos())
        if tuple in seg_pos: return False
        elif len(segments) > 0:
            if tuple in path:
                headIndex = path.index(head.pos())
                tailIndex = path.index(segments[len(segments) - 1].position())
                tupleIndex = path.index(tuple)
                #bodyRange = range(tailIndex, headIndex)
                #if tupleIndex not in bodyRange
                if headIndex <= foodIndex:
                    if tupleIndex > headIndex or tupleIndex < tailIndex:
                        if headIndex <= foodIndex and tupleIndex < headIndex: return False
                        elif headIndex <= foodIndex and tupleIndex > foodIndex: return False
                        elif foodIndex < headIndex and foodIndex < tupleIndex: 
                            if tupleIndex > headIndex: return True
                            #elif food.distance(tuple) <= food.distance(head.pos()) and tupleIndex > headIndex: return True
                            else: return False
                        #elif food.distance(tuple) < food.distance(head.pos()): return True
                        return False
                    return False
                elif headIndex > foodIndex:
                    if tupleIndex < foodIndex: return True
                    elif tupleIndex == headIndex + 1: return True
                    else: return False
            return False
        else: return True
    """
    # for n in go_list:
    #     # Behind food
    #     if path.index(head.pos()) <= path.index(food.pos()):
    #         itemIndex = path.index(n)
    #         if itemIndex <= path.index(food.pos()):
    #             if itemIndex > larIndex:
    #                 larIndex = itemIndex
    #                 direction = n
    #     # Passed food
    #     else:
    #         #print('passed food')
    #         itemIndex = path.index(n)
    #         wrap = len(path)
    #         headIndex = path.index(head.pos())
    #         foodIndex = path.index(food.pos())
    #         if itemIndex < headIndex:
    #             foodIndex += wrap
    #             itemIndex += wrap
    #             if itemIndex > larIndex and itemIndex <= foodIndex:
    #                 direction = n
    #                 larIndex = itemIndex
    #         else:
    #             #print('None')
    #             larIndex = -1
    #             direction = n